import numpy as np
import os
import matplotlib.pyplot as plt
from math import sqrt

def calc_error(sim_data_orig, real_data_orig, offset, time=True):
    sim_data = np.copy(sim_data_orig)
    real_data = np.copy(real_data_orig)
    #
    if time:
        index = 0
    else:
        index = 1
    error = 0

    sampled_sim_data = []
    normalize = True
    j = 0
    for i in range(len(real_data)):
        if real_data[i, 1] < real_data[0, 1] + 0.01:
            continue
        
        

        while sim_data[j, index] < real_data[i, index] + offset:
            j += 1
        
        if normalize:
            sim_data[:, 2] -= sim_data[j, 2]
            sim_data[:, 2] /= sim_data[-1, 2]
            normalize = False
        
        sampled_sim_data.append(j)
        error += (real_data[i, 2] - sim_data[j, 2])**2
    error /= len(sampled_sim_data)
    return sqrt(error)
    


wait_for_pour = True
pairs = [('autogenerated_0.1_speed_fix_0_0.1.text', 'real_data/yellow_cup_0.1.csv'),
         #('autogenerated_0.1_speed_fix_0_0.2.text', 'real_data/yellow_cup_0.2.csv'),
         ('autogenerated_0.1_speed_fix_0_0.05.text', 'real_data/yellow_cup_0.05.csv'),
         ('autogenerated_0.1_speed_fix_0_0.025.text', 'real_data/yellow_cup_0.025.csv'),
         ('autogenerated_0.1_speed_fix_1_0.1.text', 'real_data/flask_0.1.csv'),
        # ('autogenerated_0.1_speed_fix_1_0.2.text', 'real_data/flask_0.2.csv'),
         ('autogenerated_0.1_speed_fix_1_0.05.text', 'real_data/flask_0.05.csv'),
         ('autogenerated_0.1_speed_fix_1_0.025.text', 'real_data/flask_0.025.csv')]


from os import listdir
from os.path import isfile, join
onlyfiles = [f for f in listdir(".") if isfile(f) and 'speed_fix' in f and 'wait_times' not in f and 'params' not in f]

#pairs = [(f, 'real_data/flask_0.1.csv') for f in onlyfiles]


overall_best_error = 10**1000
overall_best_pair = None
for pair in pairs:
    
    raw_sim_data = np.loadtxt(pair[0])
    raw_real_data = np.loadtxt(pair[1])

    #print raw_sim_data.shape, raw_real_data.shape

    sim_data = np.zeros((len(raw_sim_data), 3))
    real_data = np.zeros((len(raw_real_data), 3))

    # Copy over times
    sim_data[:, 0] = raw_sim_data[:, 3]
    real_data[:, 0] = raw_real_data[:, 0] - raw_real_data[0, 0]

    # Copy over angles
    sim_data[:, 1] = raw_sim_data[:, 2]
    real_data[:, 1] = raw_real_data[:, 1] + 1.57

    # Corrects for offset between the times when the containers
    # start rotating.  Does not fix the offset from the different
    # drop distances

    # for i in range(1, len(real_data)):
    #     if real_data[i, 1] > real_data[0, 1] + 0.01:
    #         for j in range(len(sim_data)):
    #             if sim_data[j, 1] > real_data[i, 1]:
    #                 sim_data[:, 0] -= sim_data[j, 0] - real_data[i, 0]
    #                 break
    #         break



    # copy over volumes
    sim_data[:, 2] = 1.0 - 1.0 * raw_sim_data[:, 0] / raw_sim_data[0, 1]
    real_data[:, 2] = raw_real_data[:, 2] / raw_real_data[-1, 2]

    #print real_data.shape
    # Gets rid of initial flat segment
    for i in range(len(real_data)):
        if real_data[i, 2] > real_data[0, 2] + 0.05:
            #print i
            real_data = real_data[i:, :]
            real_data[:, 0] -= real_data[0, 0]
            break


    #print real_data.shape

    min_error = 10**1000
    best_offset = 0
    print sim_data[-1, 1] - real_data[-1, 1], sim_data[0, 1] - real_data[0, 1]
    # for offset in np.linspace(-10, sim_data[-1, 0] - real_data[-1, 0], 100):
    for offset in np.linspace((sim_data[0, 1] - real_data[0, 1])*0.9, (sim_data[-1, 1] - real_data[-1, 1])*.9, 100):

        error = calc_error(sim_data, real_data, offset, time=False)
        if error < min_error:
            min_error = error
            best_offset = offset
    #print "Error:", min_error, "Offset:", best_offset
    sim_data[:, 1] -= best_offset

    for i in range(len(sim_data)):
        if sim_data[i, 1] > real_data[0, 1]:
            sim_data[:, 2] -= sim_data[i, 2]
            sim_data[:, 2] /= sim_data[-1, 2]
            break

    if min_error < overall_best_error:
        overall_best_error = min_error
        overall_best_offset = offset
        overall_best_pair = pair
    

    # if wait_for_pour:
    #     for i in range(len(real_data)-1, -1, -1):
    #         if real_data[i, 2] < 0.01:
    #             for j in range(len(sim_data)):
    #                 if sim_data[j, 0] > real_data[i, 0]:
    #                     sim_data[:, 2] -= sim_data[j, 2]
    #                     sim_data[:, 2] /= sim_data[-1, 2]
    #                     break
                
    #             break

    name = pair[1].split('/')[1][:-4]
    print name
    plt.plot(sim_data[:, 0], sim_data[:, 1], label="sim")
    plt.plot(real_data[:, 0], real_data[:, 1], label="real")
    plt.legend()
    plt.savefig(name+'_time_vs_theta.png')
    plt.close()


    plt.plot(sim_data[:, 0], sim_data[:, 2], label="sim")
    plt.plot(real_data[:, 0], real_data[:, 2], label="real")
    plt.legend()
    plt.savefig(name+'_time_vs_volume.png')
    plt.close()

    plt.plot(sim_data[:, 1], sim_data[:, 2], label="sim")
    plt.plot(real_data[:, 1], real_data[:, 2], label="real")
    plt.legend()
    plt.savefig(name + '_theta_vs_volume.png')
    plt.close()
print "Best:", overall_best_error, overall_best_pair, overall_best_offset